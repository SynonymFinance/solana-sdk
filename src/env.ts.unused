import * as fs from "fs/promises";
import yargs from "yargs";
import {
  Environment,
  ProvidersOpts,
  StandardRelayerAppOpts,
} from "@wormhole-foundation/relayer-engine";
import {
  ChainId,
  CHAIN_ID_SOLANA,
  CHAIN_ID_ARBITRUM,
  CHAIN_ID_ARBITRUM_SEPOLIA,
} from "@certusone/wormhole-sdk";
import { rootLogger } from "./log.ts.unused";
import { ethers } from "ethers";
import { RedisOptions } from "ioredis";
import * as dotenv from 'dotenv';


type Opts = {
  flag: Flag;
};

enum Flag {
  Localhost = "localhost",
  Testnet = "testnet",
  Mainnet = "mainnet",
}

type ContractConfigEntry = { chainId: ChainId; address: "string" };
type ContractsJson = {
  // on-chain relayers contracts - in general relayers are just wormhole "emitter", but we keep EVM naming here for consistency
  wormholeRelayers: ContractConfigEntry[];
};

export interface CustomRelayerAppConfig {
  contractsJsonPath: string;
  name: string;
  spyEndpoint: string;
  wormholeRpcs: [string];  // this is used by fetchVaa(..) to get VAA directly from Guardian network
  providers?: ProvidersOpts;
  fetchSourceTxhash: boolean;
  logLevel: string;
  logFormat: "json" | "text";
  redis?: RedisOptions;
  redisCluster?: StandardRelayerAppOpts["redisCluster"];
  redisClusterEndpoints?: StandardRelayerAppOpts["redisClusterEndpoints"];
  ipWhitelist?: [string];
}

const defaults: { [key in Flag]: CustomRelayerAppConfig } = {
  [Flag.Localhost]: {
    contractsJsonPath: `./config/localhost/contracts.json`,
    name: "Evm-Solana-Relayer",
    logLevel: "debug",
    logFormat: "text",
    spyEndpoint: "localhost:7073",
    wormholeRpcs: ["https://api.testnet.wormholescan.io"],
    providers: {
          // endpoints to local nodes run with anvil/hardhat and Solana test validator
          chains: {
            [CHAIN_ID_ARBITRUM_SEPOLIA]: {
              endpoints: ["http://localhost:8545/"],
            },
            [CHAIN_ID_SOLANA]: {
              endpoints: ["http://localhost:8546/"],
            },
          },
    },
    fetchSourceTxhash: true,
    redis: { host: "localhost", port: 6379 },
  },
  [Flag.Testnet]: {
    contractsJsonPath: `./config/testnet/contracts.json`,
    name: "Evm-Solana-Relayer",
    logLevel: "debug",
    logFormat: "text",
    // spyEndpoint: "localhost:7073", // local spy
    // spyEndpoint: "localhost:7072", // local beacon
    // spyEndpoint: "209.38.251.243:7073", // remote spy 
    spyEndpoint: "209.38.251.243:7072", // remote beacon 
    wormholeRpcs: ["https://api.testnet.wormholescan.io"],
    providers: {
        // TODO: use infura or alchemy with dedicated keys so that we are not rate limited
        chains: {
          [CHAIN_ID_ARBITRUM_SEPOLIA]: {
            endpoints: ["https://sepolia-rollup.arbitrum.io/rpc"],
          },
          [CHAIN_ID_SOLANA]: {
            endpoints: ["https://api.devnet.solana.com"],
          },
        },
    },
    fetchSourceTxhash: true,
    redis: { host: "localhost", port: 6379 },
  },
  [Flag.Mainnet]: {
    contractsJsonPath: `./config/mainnet/contracts.json`,
    name: "Evm-Solana-Relayer",
    logLevel: "debug",
    logFormat: "text",
    spyEndpoint: "localhost:7073",
    wormholeRpcs: ["https://api.wormholescan.io"],
    providers: {
        // TODO: use infura or alchemy with dedicated keys so that we are not rate limited
        chains: {
          [CHAIN_ID_ARBITRUM]: {
            endpoints: ["https://arbitrum.llamarpc.com"],
          },
          [CHAIN_ID_SOLANA]: {
            endpoints: ["https://api.mainnet-beta.solana.com"],
          },
        },
    },
    fetchSourceTxhash: true,
    redis: { host: "localhost", port: 6379 },
  },
};

export async function loadAppConfig(): Promise<{
  env: Environment;
  opts: CustomRelayerAppConfig & StandardRelayerAppOpts;
  wormholeRelayers: Record<ChainId, string>;
}> {
  dotenv.config();
  const { flag } = getEnvironmentOptions();
  const config = await loadAndMergeConfig(flag);
  // here we are loading the emitter contracts addresses (on-chain relayers)
  const contracts = await loadJson<ContractsJson>(config.contractsJsonPath);

  const wormholeRelayers = {} as Record<ChainId, string>;

  contracts.wormholeRelayers.forEach(
    ({ chainId, address }: ContractConfigEntry) => {
      if (chainId != CHAIN_ID_SOLANA) {
        (wormholeRelayers[chainId] = ethers.utils.getAddress(address))
      } else {
        wormholeRelayers[chainId] = address
      }
    }
  );

  return {
    wormholeRelayers,
    env: flagToEnvironment(flag),
    opts: {
      ...config,
      logger: rootLogger(config.logLevel, config.logFormat),
      privateKeys: privateKeys(contracts),
      concurrency: 1 // TODO: explore if we can use it safely
    },
  };
}

function getEnvironmentOptions(): Opts {
  let opts = yargs(process.argv.slice(2)).argv as unknown as Opts;
  if (opts.flag == undefined) {
    console.log("WARNING: not env flag specified using Localhost as default");
    opts.flag = Flag.Localhost;
  }
  if (!validateStringEnum(Flag, opts.flag)) {
    throw new Error("Unrecognized flag variant: " + opts.flag);
  }
  return opts;
}

function loadAndMergeConfig(flag: Flag): CustomRelayerAppConfig {
  const base = defaults[flag];
  const isRedisCluster = !!process.env.REDIS_CLUSTER_ENDPOINTS;
  return {
    name: process.env.GENERIC_RELAYER_NAME || base.name,
    contractsJsonPath: process.env.CONTRACTS_JSON_PATH || base.contractsJsonPath,
    logFormat: (process.env.LOG_FORMAT as "text" | "json") || base.logFormat,
    logLevel: process.env.LOG_LEVEL || base.logLevel,
    spyEndpoint: process.env.SPY_URL || base.spyEndpoint,
    wormholeRpcs: process.env.WORMHOLE_RPCS
      ? JSON.parse(process.env.WORMHOLE_RPCS)
      : base.wormholeRpcs,
    providers: process.env.BLOCKCHAIN_PROVIDERS
      ? JSON.parse(process.env.BLOCKCHAIN_PROVIDERS)
      : base.providers,
    fetchSourceTxhash: process.env.FETCH_SOURCE_TX_HASH
      ? JSON.parse(process.env.FETCH_SOURCE_TX_HASH)
      : base.fetchSourceTxhash,

    redisClusterEndpoints: process.env.REDIS_CLUSTER_ENDPOINTS?.split(","), // "url1:port,url2:port"
    redisCluster: isRedisCluster
      ? {
          dnsLookup: (address: any, callback: any) => callback(null, address),
          slotsRefreshTimeout: 1000,
          redisOptions: {
            tls: process.env.REDIS_TLS ? {} : base.redis?.tls,
            username: process.env.REDIS_USERNAME,
            password: process.env.REDIS_PASSWORD,
          },
        }
      : undefined,
    redis: <RedisOptions>{
      tls: process.env.REDIS_TLS ? {} : base.redis?.tls,
      host: process.env.REDIS_HOST ? process.env.REDIS_HOST : base.redis?.host,
      port: process.env.REDIS_CLUSTER_ENDPOINTS
        ? undefined
        : Number(process.env.REDIS_PORT) || base.redis?.port,
      username: process.env.REDIS_USERNAME,
      password: process.env.REDIS_PASSWORD,
    },
    ipWhitelist: process.env.IP_WHITELIST ? JSON.parse(process.env.IP_WHITELIST) : ["127.0.0.*"],
  };
}

function privateKeys(contracts: ContractsJson): {
  [k in Partial<ChainId>]: string[];
} {
  const hubChainId = parseInt(process.env.HUB_CHAIN_ID!) as ChainId;
  const privateKeys = {} as Record<ChainId, string[]>;
  if (process.env.EVM_PRIVATE_KEY) {
    const privateEvmKeysArray = [process.env.EVM_PRIVATE_KEY];
    privateKeys[hubChainId] = privateEvmKeysArray;
  }  
  if (process.env.SOLANA_PRIVATE_KEY) {
    const privateSolanaKeysArray = [process.env.SOLANA_PRIVATE_KEY];
    privateKeys[CHAIN_ID_SOLANA as ChainId] = privateSolanaKeysArray;
  } 

  return privateKeys;
}

function flagToEnvironment(flag: Flag): Environment {
  switch (flag) {
    case Flag.Localhost:
      return Environment.DEVNET;
    case Flag.Testnet:
      return Environment.TESTNET;
    case Flag.Mainnet:
      return Environment.MAINNET;
  }
}

function validateStringEnum<O extends Object>(
  enumObject: O,
  passed: string
): boolean {
  for (const value of Object.values(enumObject)) {
    if (value === passed) {
      return true;
    }
  }
  return false;
}

function loadJson<T>(path: string): Promise<T> {
  return fs
    .readFile(path, {
      encoding: "utf-8",
    })
    .then(JSON.parse) as Promise<T>;
}